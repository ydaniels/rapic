import json
from urllib.parse import urlsplit, urlunparse, ParseResult
from rapic.connection.hook import APIHook
from rapic.base import BaseClient
from rapic.tools import delete_keys


class APIClient(APIHook, BaseClient):
    """
        This is used directly by end user to perform actual request
        api = APICLient(client_name = 'instagram',burp_req_file_loc='burp_saved_requests.json')

        api.get_my_followers()
        or
        api.get_user_followers(post_data ={ 'user_id' : '2343434' })
        or
        api.perform_requests('get_my_followers')
        or
        api.perform_requests('users/{user_id}/info/', post_data ={ 'user_id' : '2343434' }  )

        Client must inherit from this class and supply at least the client name and manually crafted json file
        or json file automatically generated by rapic from a saved xml requests file reverse engineering software.
        It also exposes hooks from parent class you can use to perform extra cleaning or processing of request such as
         request signing, authentication, timestamp generation before making the actual request.

     """

    IGNORE_URL_FIELDS = []
    IGNORE_POST_FIELDS = []
    IGNORE_POST_VALUE = []
    IGNORE_URL_FIELDS_VALUE = []
    LOGIN_REQUEST_NAME = ''
    LOGOUT_REQUEST_NAME = ''
    CLIENT_REQUESTS = {}
    MAP_FIELDS = {}

    def __init__(self, client, request_file, **kwargs):
        self.file_location = request_file
        self.name = client

        with open(request_file, 'r') as j:
            self.client = json.loads(j.read())[client]
            self.requests = {}
            APIClient.CLIENT_REQUESTS[client] = self.requests
            super(APIClient, self).__init__(client, **kwargs)

    @staticmethod
    def _remove_ignored_fields(data, ignore_fields):
        for field in ignore_fields:
            if field in data:
                del data[field]
        return data

    @staticmethod
    def _confirm_request_data(data_fields, data):
        final_data = {}
        for field, value in data_fields.iteritems():
            if field not in data or (field in data and data[field] is None):

                if field in APIClient.MAP_FIELDS and data[APIClient.MAP_FIELDS[field]] is not None:
                    final_data[field] = data[APIClient.MAP_FIELDS[field]]
                else:
                    raise Exception('%s most be present in url fields ' % field)
            else:
                final_data[field] = data[field]
        return final_data

    def clean_request(self, request_name):
        """Clean a request by removing uneccessary values and data from it"""
        login_request = False
        logout_request = False
        extra_action = None
        request = self.get_request(request_name)
        if not request:
            raise Exception('Request %s does not exist please check loaded requests and try again ' % request_name)
        url_data = request['url_data']
        post_data = request['body_data']

        if self.LOGIN_REQUEST_NAME == request_name:
            login_request = True

        if self.LOGOUT_REQUEST_NAME == request_name:
            logout_request = True

        url_data = self._remove_ignored_fields(url_data, APIClient.IGNORE_URL_FIELDS)
        post_data = self._remove_ignored_fields(post_data, APIClient.IGNORE_POST_FIELDS)

        if 'extra_requests' in request_name:
            extra_action = request_name['extra_requests']
        data = {'name': request_name, 'url_fields': delete_keys(url_data), 'post_fields': delete_keys(post_data),
                'is_login_request': login_request, 'extra_request': extra_action, 'is_logout_request': logout_request}

        return data

    def confirm_request_data(self, request_name, data):
        """
        Build a clean url_data and post_data and return the cleaned versions by removing unnecessary fields in each data
        and mapping it to a new old fields to new ones if necessary
        :param request_name:
        :param data:
        :return:
        """

        cleaned_request = self.clean_request(request_name)

        url_fields = cleaned_request.get('url_fields', {})
        post_fields = cleaned_request.get('post_fields', {})

        final_url_data = self._confirm_request_data(url_fields, data)
        final_post_data = self._confirm_request_data(post_fields, data)

        return final_url_data, final_post_data

    def perform_request(self, request_name, do_extra_requests=False, do_implicit_requests=False, **kwargs):
        """
        Perform the actual http request specified by request_name in rapic json file
        :param request_name:
        :param do_extra_requests: Todo
        :param do_implicit_requests: Todo
        :param kwargs:
        :return:
        """
        request = self.get_request(request_name)

        request['request_name'] = request_name

        return self.execute_request(request, **kwargs)

    @staticmethod
    def _append_data_to_url(url, data):
        if not data:
            return url
        for k, v in data.items():
            url = url + '&' + k + '=' + v
        return url

    def execute_request(self, request, headers=None, url_data=None, post_data=None, append_url=None):
        """
         Takes a request and execute the request using created session from RequestClient
         you can also pass headers, url data,  post data directly to override headers saved in the rapic json file.
         Hooks registered by API Client will be called here with the appropriate data

        :param request: The saved rapic request that should be performed
        :param headers: Headers to over-ride saved headers in json file
        :param url_data: Url data to over-ride saved default url data
        :param post_data: Post data to over-ride saved body fields
        :param append_url: you can update external field not recorded in the json file using append_url dict
                           E.G append_url = {'load_false':1} will url  = url + ?load_false=1
        :return: Response Object
        """

        request_name = request['request_name']

        path = request['path'].format(url_data)
        url_schema = urlsplit(request['url'])
        query = url_schema.query
        if url_data:
            query = query.format(url_data)

        url = urlunparse(
            ParseResult(netloc=request['host'], scheme=request['scheme'], path=path, query=query, params=None,
                        fragment=''))

        url = self._append_data_to_url(url, append_url)

        # Run client registered function before a request is performed
        # function registered as header,url, post hooks will recieve headers, url data, post data as an arguement
        # while the ones register as request  hook will recieve the full request before it is sent
        # They can do whatever they want with it and must return it back as this will be set as the new
        # data for each of them respectively before the request is being done
        new_header = self._run_hook_func(request_name, headers or request['headers'], self.HEADER_HOOK_TYPE)
        new_url_data = self._run_hook_func(request_name, url_data or request['url_data'], self.URL_DATA_HOOK_TYPE)
        new_post_data = self._run_hook_func(request_name, post_data or request['body_data'], self.POST_DATA_HOOK_TYPE)

        request['url'] = url
        request['headers'].update(new_header)
        request['url_data'].update(new_url_data)
        request['body_data'].update(new_post_data)
        if request.get("body_is_json", False):
            request['body_data'] = json.dumps(request['body_data'])
        request = self._run_hook_func(request_name, request, self.REQUEST_HOOK_TYPE)
        prep_req_obj = self.s.prepare_requests_request(request)
        new_req_obj = self._run_hook_func(request_name, prep_req_obj, self.REQUESTS_OBJ_HOOK_TYPE)
        response = self.s.execute(new_req_obj)
        response = self._run_hook_func(request_name, response, self.RESPONSE_OBJ_HOOK_TYPE)
        return response

    def get_request(self, request_name):
        """Get a particular request by name from all requests this api client can perform"""
        request = self.requests.get(request_name)
        if request:
            return request
        request = self.client.get(request_name)
        if not request:

            pages = self.client.get('pages', [])
            for page_name in pages:
                page = self.client[page_name]
                if request_name in page:
                    request = page[request_name]
                    break

        if not request:
            raise Exception('Are you sure request %s exist in json file. Sorry cannot execute request'% request_name)
        self.requests[request_name] = request
        return request

    def get_total_requests_number(self):
        return len(self.requests)

    def get_pages_number(self):
        return len(self.client.get('pages', 0))

    def get_pages(self):
        if not self.client.get('pages', 0):
            raise Exception('This api client does not have pages implemented')
        return self.client['pages']

    def get_requests(self):
        return self.requests

    def info(self):
        req_data = dict()
        req_data['client_name'] = self.name.title()
        req_data['total_pages'] = self.get_pages_number()
        req_data['total_requests'] = self.get_total_requests_number()
        req_data['requests'] = self.get_requests()
        return req_data
